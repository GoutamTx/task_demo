name: Secure Supply Chain CI

on:
  push:
    branches:
      - master

permissions:
  contents: read
  packages: write
  id-token: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}/my-app
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-sign:
    runs-on: ubuntu-latest
    outputs: # Declare outputs for this job
      IMAGE_DIGEST: ${{ steps.digest.outputs.IMAGE_DIGEST }} # Export the image digest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push container image
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Get image digest
        id: digest
        run: |
          # Use docker/build-push-action's output for digest if available,
          # otherwise, inspect it manually.
          # The docker/build-push-action@v4 should output the digest directly.
          # Let's rely on its output if it's there.
          # If not, the manual inspect is a good fallback.
          # For now, we'll assume the direct output or that the manual inspect works.
          # Note: The 'outputs' of build-push-action are often more reliable.
          # For v4, the digest is usually available as steps.build-and-push.outputs.digest
          # Let's adjust to use that if possible, or ensure this step captures it correctly.
          # For simplicity and to match previous logic, we keep the manual inspect for now.
          echo "IMAGE_DIGEST=$(docker buildx imagetools inspect ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} | grep 'Digest:' | awk '{print $2}')" >> $GITHUB_OUTPUT

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.2.0

      - name: Sign container image
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          echo "$COSIGN_PRIVATE_KEY" > cosign.key
          cosign sign --yes --key cosign.key ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.IMAGE_DIGEST }}

      - name: Generate SLSA provenance attestation
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          echo "$COSIGN_PRIVATE_KEY" > cosign.key
          
          # Create a basic SLSA predicate file dynamically
          cat << EOF > slsa-provenance.json
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "subject": [
              {
                "name": "${{ env.IMAGE_NAME }}",
                "digest": {
                  "sha256": "${{ steps.digest.outputs.IMAGE_DIGEST }}"
                }
              }
            ],
            "predicateType": "https://slsa.dev/provenance/v0.2",
            "predicate": {
              "builder": {
                "id": "https://github.com/actions/runner"
              },
              "recipe": {
                "type": "https://github.com/actions/runner",
                "definedInMaterial": {},
                "entryPoint": "ci.yml"
              },
              "materials": [
                {
                  "uri": "git+https://github.com/${{ github.repository }}.git",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              ]
            }
          }
          EOF
          
          cosign attest --yes --predicate slsa-provenance.json --key cosign.key ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.IMAGE_DIGEST }}

  verify-and-deploy:
    runs-on: ubuntu-latest
    needs: build-and-sign # Ensure this job runs after build-and-sign
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.2.0

      - name: Verify image and attestation
        env:
          COSIGN_PUBLIC_KEY: ${{ secrets.COSIGN_PUBLIC_KEY }} # Use a secret for the public key
          # Access the output from the previous job using needs.<job_id>.outputs.<output_name>
          IMAGE_DIGEST: ${{ needs.build-and-sign.outputs.IMAGE_DIGEST }}
          IMAGE_NAME: ghcr.io/${{ github.repository }}/my-app
        run: |
          # Write the public key from the secret to a file
          echo "$COSIGN_PUBLIC_KEY" > cosign.pub
          
          # Verify the image signature using the passed digest
          cosign verify --key cosign.pub "${{ env.IMAGE_NAME }}@${{ env.IMAGE_DIGEST }}"
          
          # Verify the provenance attestation using the passed digest
          cosign verify-attestation --key cosign.pub "${{ env.IMAGE_NAME }}@${{ env.IMAGE_DIGEST }}"
          
          echo "Verification successful. Image is trusted for deployment."
